<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Daisyworld · Agents.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Agents.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Agents.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../tutorial/">Tutorial</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../schelling/">Schelling&#39;s segregation model</a></li><li><a class="tocitem" href="../sir/">SIR model for the spread of COVID-19</a></li><li><a class="tocitem" href="../social_distancing/">Continuous space social distancing for COVID-19</a></li><li><a class="tocitem" href="../wealth_distribution/">Wealth distribution</a></li><li><a class="tocitem" href="../forest_fire/">Forest fire</a></li><li><a class="tocitem" href="../game_of_life_2D_CA/">Conway&#39;s game of life</a></li><li><a class="tocitem" href="../wright-fisher/">Wright-Fisher model of evolution</a></li><li><a class="tocitem" href="../HK/">Hegselmann-Krause opinion dynamics</a></li><li><a class="tocitem" href="../flock/">Flocking</a></li><li class="is-active"><a class="tocitem" href>Daisyworld</a><ul class="internal"><li><a class="tocitem" href="#Overview-of-Daisyworld-1"><span>Overview of Daisyworld</span></a></li><li><a class="tocitem" href="#Defining-the-agent-type-1"><span>Defining the agent type</span></a></li><li><a class="tocitem" href="#World-heating-1"><span>World heating</span></a></li><li><a class="tocitem" href="#Initialising-Daisyworld-1"><span>Initialising Daisyworld</span></a></li><li><a class="tocitem" href="#Model-dynamics-1"><span>Model dynamics</span></a></li><li><a class="tocitem" href="#Look-at-the-pretty-flowers!-1"><span>Look at the pretty flowers!</span></a></li></ul></li><li><a class="tocitem" href="../predator_prey/">Predator-Prey</a></li><li><a class="tocitem" href="../growing_bacteria/">Bacteria Growth</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li><li><a class="tocitem" href="../../mesa/">Comparison against Mesa (Python)</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Daisyworld</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Daisyworld</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/Agents.jl/blob/master/examples/daisyworld.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Daisyworld-1"><a class="docs-heading-anchor" href="#Daisyworld-1">Daisyworld</a><a class="docs-heading-anchor-permalink" href="#Daisyworld-1" title="Permalink"></a></h1><p><img src="daisyworld.gif" alt/></p><p>Study this example to learn about</p><ul><li>Simple agent properties with complex model interactions</li><li>Rolling your own plots</li><li>Collecting data with the low-level data collection API</li><li>Simultaneously plotting and collecting data</li><li>Analyzing the behavior of a model</li></ul><h2 id="Overview-of-Daisyworld-1"><a class="docs-heading-anchor" href="#Overview-of-Daisyworld-1">Overview of Daisyworld</a><a class="docs-heading-anchor-permalink" href="#Overview-of-Daisyworld-1" title="Permalink"></a></h2><p>This model explores the <a href="https://en.wikipedia.org/wiki/Gaia_hypothesis">Gaia hypothesis</a>, which considers the Earth as a single, self-regulating system including both living and non-living parts.</p><p>Daisyworld is filled with black and white daisies. Their albedo&#39;s differ, with black daisies absorbing light and heat, warming the area around them; white daisies doing the opposite. Daisies can only reproduce within a certain temperature range, meaning too much (or too little) heat coming from the sun and/or surrounds will ultimately halt daisy propagation.</p><p>When the climate is too cold it is necessary for the black daisies to propagate in order to raise the temperature, and vice versa – when the climate is too warm, it is necessary for more white daisies to be produced in order to cool the temperature. The interplay of the living and non living aspects of this world manages to find an equilibrium over a wide range of parameter settings, although with enough external forcing, the daisies will not be able to self regulate the temperature of the planet and eventually go extinct.</p><h2 id="Defining-the-agent-type-1"><a class="docs-heading-anchor" href="#Defining-the-agent-type-1">Defining the agent type</a><a class="docs-heading-anchor-permalink" href="#Defining-the-agent-type-1" title="Permalink"></a></h2><p>The agent here is not so complex. We see it has three values (other than the required <code>id</code> and <code>pos</code> for an agent that lives on a <a href="../../tutorial/#Agents.GridSpace"><code>GridSpace</code></a>. Each daisy has an <code>age</code>, confined later by a maximum age set by the user, a <code>breed</code> (either <code>:black</code> or <code>:white</code>) and an associated <code>albedo</code> value, again set by the user.</p><pre><code class="language-">using Agents, AgentsPlots, Plots, Random
using Statistics: mean
pyplot() # hide

mutable struct Daisy &lt;: AbstractAgent
    id::Int
    pos::Tuple{Int,Int}
    breed::Symbol
    age::Int
    albedo::Float64 # 0-1 fraction
end</code></pre><h2 id="World-heating-1"><a class="docs-heading-anchor" href="#World-heating-1">World heating</a><a class="docs-heading-anchor-permalink" href="#World-heating-1" title="Permalink"></a></h2><p>The surface temperature of the world is heated by its sun, but daisies growing upon it absorb or reflect the starlight – altering the local temperature.</p><pre><code class="language-">function suface_temperature!(node::Int, model::ABM{Daisy})
    ids = get_node_contents(node, model)
    absorbed_luminosity = if isempty(ids)
        # Set luminosity via surface albedo
        (1 - model.surface_albedo) * model.solar_luminosity
    else
        # Set luminosity via daisy albedo
        (1 - model[ids[1]].albedo) * model.solar_luminosity
    end
    # We expect local heating to be 80C for an absorbed luminosity of 1,
    # approximately 30 for 0.5 and approximately -273 for 0.01.
    local_heating = if absorbed_luminosity &gt; 0
        72 * log(absorbed_luminosity) + 80
    else
        80
    end
    # Surface temperature is the average of the current temperature and local heating.
    model.temperature[node] = (model.temperature[node] + local_heating) / 2
end

function diffuse_temperature!(node::Int, model::ABM{Daisy}; ratio = 0.5)
    neighbors = node_neighbors(node, model)
    model.temperature[node] =
        (1 - ratio) * model.temperature[node] +
        # Each neighbor is giving up 1/8 of the diffused
        # amount to each of *its* neighbors
        sum(model.temperature[neighbors]) * 0.125 * ratio
end</code></pre><h2 id="Initialising-Daisyworld-1"><a class="docs-heading-anchor" href="#Initialising-Daisyworld-1">Initialising Daisyworld</a><a class="docs-heading-anchor-permalink" href="#Initialising-Daisyworld-1" title="Permalink"></a></h2><p>Here, we construct a function to initialize a Daisyworld. We need to know how many daisies of each type to seed the planet with and what their albedo&#39;s are. The albedo of the planet, as well as how intense the world&#39;s star tends to be. Alternatively we can provide a <code>scenario</code> flag, which alters the stars luminosity in different ways.</p><pre><code class="language-julia">function daisyworld(;
    griddims = (30, 30),
    max_age = 25,
    init_white = 20, # % cover of the world surface of white breed
    init_black = 20, # % cover of the world surface of black breed
    albedo_white = 0.75,
    albedo_black = 0.25,
    albedo_surface = 0.4,
    solar_luminosity = 0.8,
    scenario = :default,
)
    @assert scenario ∈ [
        :default, # User provided solar_luminosity
        :ramp, # Increase &amp; decrease luminosity over an 850 year period
        :high, # White daisies will prefer this climate
        :low, # Black daisies will prefer this climate
        :ours, # The Sun&#39;s equivalent, achieving an equilibrium of daisies
    ]

    space = GridSpace(griddims, moore = true, periodic = true)
    luminosity = if scenario == :ramp
        0.8
    elseif scenario == :high
        1.4
    elseif scenario == :low
        0.6
    elseif scenario == :ours
        1.0
    else
        solar_luminosity
    end

    properties = Dict(
        :max_age =&gt; max_age,
        :temperature =&gt; zeros(prod(griddims)),
        :surface_albedo =&gt; albedo_surface,
        :solar_luminosity =&gt; luminosity,
        :scenario =&gt; scenario,
        :tick =&gt; 0,
    )
    model = ABM(Daisy, space; properties = properties)
    for _ in 1:(init_white * nv(space) / 100)
        add_agent_single!(model, :white, rand(0:max_age), albedo_white)
    end
    for _ in 1:(init_black * nv(space) / 100)
        add_agent_single!(model, :black, rand(0:max_age), albedo_black)
    end
    for n in nodes(model)
        suface_temperature!(n, model)
    end
    return model
end</code></pre><pre><code class="language-none">daisyworld (generic function with 1 method)</code></pre><h2 id="Model-dynamics-1"><a class="docs-heading-anchor" href="#Model-dynamics-1">Model dynamics</a><a class="docs-heading-anchor-permalink" href="#Model-dynamics-1" title="Permalink"></a></h2><p>The final piece of the puzzle is the life-cycle of each daisy. This method defines an optimal temperature for growth. If the temperature gets too hot or too cold, daisies will not wish to propagate and may even die out. So long as the temperature is favorable, daisies compete for land and attempt to spawn a new plant of their <code>breed</code> in locations close to them.</p><pre><code class="language-">function propagate!(node::Int, model::ABM{Daisy})
    agents = get_node_agents(node, model)
    if !isempty(agents)
        agent = agents[1]
        temperature = model.temperature[node]
        # Set optimum growth rate to 22.5C, with bounds of [5, 40]C
        seed_threshold = (0.1457 * temperature - 0.0032 * temperature^2) - 0.6443
        if rand() &lt; seed_threshold
            # Collect all adjacent cells that are empty
            empty_neighbors = Vector{Int}(undef, 0)
            neighbors = node_neighbors(node, model)
            for n in neighbors
                if isempty(get_node_contents(n, model))
                    push!(empty_neighbors, n)
                end
            end
            if !isempty(empty_neighbors)
                # Seed a new daisy in one of those cells
                seeding_place = rand(empty_neighbors)
                add_agent!(seeding_place, model, agent.breed, 0, agent.albedo)
            end
        end
    end
end</code></pre><p>Now, we need to write the model and agent step functions for Agents.jl to advance Daisyworld&#39;s dynamics. Since we have constructed a number of helper functions, these methods are quite straightforward.</p><pre><code class="language-">function solar_activity!(model::ABM{Daisy})
    if model.scenario == :ramp
        if model.tick &gt; 200 &amp;&amp; model.tick &lt;= 400
            model.solar_luminosity += 0.005
        end
        if model.tick &gt; 500 &amp;&amp; model.tick &lt;= 750
            model.solar_luminosity -= 0.0025
        end
    end
end

function model_step!(model::ABM{Daisy})
    for n in nodes(model)
        suface_temperature!(n, model)
        diffuse_temperature!(n, model)
        propagate!(n, model)
    end
    model.tick += 1
    solar_activity!(model)
end

function agent_step!(agent::Daisy, model::ABM{Daisy})
    agent.age += 1
    agent.age &gt;= model.max_age &amp;&amp; kill_agent!(agent, model)
end</code></pre><h2 id="Look-at-the-pretty-flowers!-1"><a class="docs-heading-anchor" href="#Look-at-the-pretty-flowers!-1">Look at the pretty flowers!</a><a class="docs-heading-anchor-permalink" href="#Look-at-the-pretty-flowers!-1" title="Permalink"></a></h2><p>Lets run the model for a bit and see what our world looks like when the solar activity is similar to that of our own:</p><pre><code class="language-">Random.seed!(165) # hide
model = daisyworld(scenario = :ours)
step!(model, agent_step!, model_step!, 100)
daisycolor(a) = a.breed
plotabm(model; ac = daisycolor, as = 5)</code></pre><p>We can see that this world achieves quasi-equilibrium, where one <code>breed</code> does not totally dominate the other.</p><pre><code class="language-">sum(map(a -&gt; [a.breed == :white, a.breed == :black], allagents(model)))</code></pre><hr/><p>Now we&#39;ll take a look at some of the complex dynamics this world can manifest. Some of these methods are, for the moment, not implemented in <a href="https://github.com/JuliaDynamics/AgentsPlots.jl">AgentsPlots</a>, although this does give us an opportunity to test out some of the new data collection features in Agents.jl v3.0. <em>Think you have a nice recipe for a plot that would help others?</em> <a href="https://github.com/JuliaDynamics/AgentsPlots.jl/pulls">Send us a pull request</a> or <a href="https://github.com/JuliaDynamics/AgentsPlots.jl/issues">open an issue</a>.</p><p>First, our fluctuating solar luminosity scenario.</p><pre><code class="language-">model = daisyworld(scenario = :ramp)</code></pre><p>Then, let us initialize some dataframes for our model and agents. We are interested in the global surface temperature, the current solar luminosity and populations of each daisy breed. Notice that we made sure that <code>sum</code> has been given a default value since this model is using <code>kill_agent!</code> (see <a href="../../tutorial/#Agents.run!"><code>run!</code></a> for more details).</p><pre><code class="language-">global_temperature(model) = mean(model.temperature)
mdata = [global_temperature, :solar_luminosity]
model_df = init_model_dataframe(model, mdata)

white(agent) = agent.breed == :white
black(agent) = agent.breed == :black
total(v) = length(v) == 0 ? 0.0 : sum(v)
adata = [(white, total), (black, total)]
agent_df = init_agent_dataframe(model, adata);
nothing #hide</code></pre><p>Now we can evolve our model and observe what happens</p><pre><code class="language-">anim = @animate for t in 1:900
    step!(model, agent_step!, model_step!, 1)
    collect_model_data!(model_df, model, mdata, t)
    collect_agent_data!(agent_df, model, adata, t)
    heatmap(
        1:model.space.dimensions[1],
        1:model.space.dimensions[2],
        transpose(reshape(model.temperature, model.space.dimensions));
        clims = (-50, 110),
        colorbar_title = &quot;Temperature&quot;,
    )
    scatter!(
        [a.pos for a in allagents(model)];
        marker = (:circle, 6),
        markercolor = [a.breed for a in allagents(model)],
        label = :none,
        showaxis = false,
    )
end
gif(anim, &quot;daisyworld.gif&quot;, fps = 10)</code></pre><p>Very interesting! But why is this all happening? Luckily we have collected some useful data, so now if we plot our different properties over the same time period, we can see how each of the values effect Daisyworld as a whole.</p><pre><code class="language-">p1 = plot(model_df[!, :solar_luminosity], legend = false, ylabel = &quot;Solar Luminosity&quot;)
p2 = plot(model_df[!, :global_temperature], legend = false, ylabel = &quot;Global Temperature&quot;)
p3 = plot(
    [agent_df[!, aggname(white, total)], agent_df[!, aggname(black, total)]],
    legend = false,
    ylabel = &quot;Population&quot;,
)
plot(p1, p2, p3, layout = (3, 1), size = (500, 800))</code></pre><p>We observe an initial period of low solar luminosity which favors a large population of black daisies. The population however is kept in check by competition from white daisies and a semi-stable global temperature regime is reached, fluctuating between ~32 and 41 degrees.</p><p>An increase in solar luminosity forces a population inversion, then a struggle for survival for the black daisies – which ultimately leads to their extinction. At extremely high solar output the white daisies dominate the landscape, leading to a uniform surface temperature.</p><p>Finally, as the sun fades back to normal levels, both the temperature and white daisy population struggle to find equilibrium. The counterbalancing force of the black daisies being absent, Daisyworld is plunged into a chaotic regime – indicating the strong role biodiversity has to play in stabilizing climate.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../flock/">« Flocking</a><a class="docs-footer-nextpage" href="../predator_prey/">Predator-Prey »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 30 April 2020 11:57">Thursday 30 April 2020</span>. Using Julia version 1.4.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
