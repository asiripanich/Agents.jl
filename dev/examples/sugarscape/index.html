<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sugarscape · Agents.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Agents.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Agents.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../tutorial/">Tutorial</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../schelling/">Schelling&#39;s segregation model</a></li><li class="is-active"><a class="tocitem" href>Sugarscape</a><ul class="internal"><li><a class="tocitem" href="#Model-structure"><span>Model structure</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../sir/">SIR model for the spread of COVID-19</a></li><li><a class="tocitem" href="../social_distancing/">Continuous space social distancing for COVID-19</a></li><li><a class="tocitem" href="../wealth_distribution/">Wealth distribution</a></li><li><a class="tocitem" href="../forest_fire/">Forest fire</a></li><li><a class="tocitem" href="../game_of_life_2D_CA/">Conway&#39;s game of life</a></li><li><a class="tocitem" href="../wright-fisher/">Wright-Fisher model of evolution</a></li><li><a class="tocitem" href="../hk/">Hegselmann-Krause opinion dynamics</a></li><li><a class="tocitem" href="../flock/">Flocking</a></li><li><a class="tocitem" href="../daisyworld/">Daisyworld</a></li><li><a class="tocitem" href="../predator_prey/">Predator-Prey</a></li><li><a class="tocitem" href="../growing_bacteria/">Bacteria Growth</a></li><li><a class="tocitem" href="../opinion_spread/">Opinion spread</a></li></ul></li><li><a class="tocitem" href="../../models/">Predefined Models</a></li><li><a class="tocitem" href="../../api/">API</a></li><li><a class="tocitem" href="../../interact/">Interactive application</a></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Ecosystem Integration</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../diffeq/">DifferentialEquations.jl</a></li><li><a class="tocitem" href="../optim/">BlackBoxOptim</a></li></ul></li><li><a class="tocitem" href="../../mesa/">Comparison against Mesa (Python)</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Sugarscape</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Sugarscape</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/Agents.jl/blob/master/examples/sugarscape.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Sugarscape:-growing-artificial-societies"><a class="docs-heading-anchor" href="#Sugarscape:-growing-artificial-societies">Sugarscape: growing artificial societies</a><a id="Sugarscape:-growing-artificial-societies-1"></a><a class="docs-heading-anchor-permalink" href="#Sugarscape:-growing-artificial-societies" title="Permalink"></a></h1><p><img src="sugar.gif" alt/></p><p>(Descriptions below are from <a href="http://jasss.soc.surrey.ac.uk/12/1/6/appendixB/EpsteinAxtell1996.html">this page</a>)</p><hr/><p>&quot;Growing Artificial Societies&quot; (Epstein &amp; Axtell 1996) is a reference book for scientists interested in agent-based modelling and computer simulation. It represents one of the most paradigmatic and fascinating examples of the so-called generative approach to social science (Epstein 1999). In their book, Epstein &amp; Axtell (1996) present a computational model where a heterogeneous population of autonomous agents compete for renewable resources that are unequally distributed over a 2-dimensional environment. Agents in the model are autonomous in that they are not governed by any central authority and they are heterogeneous in that they differ in their genetic attributes and their initial environmental endowments (e.g. their initial location and wealth). The model grows in complexity through the different chapters of the book as the agents are given the ability to engage in new activities such as sex, cultural exchange, trade, combat, disease transmission, etc. The core of Sugarscape has provided the basis for various extensions to study e.g. norm formation through cultural diffusion (Flentge et al. 2001) and the emergence of communication and cooperation in artificial societies (Buzing et al. 2005). Here we analyse the model described in the second chapter of Epstein &amp; Axtell&#39;s (1996) book within the Markov chain framework.</p><h2 id="Model-structure"><a class="docs-heading-anchor" href="#Model-structure">Model structure</a><a id="Model-structure-1"></a><a class="docs-heading-anchor-permalink" href="#Model-structure" title="Permalink"></a></h2><p>The first model that Epstein &amp; Axtell (1996) present comprises a finite population of agents who live in an environment. The environment is represented by a two-dimensional grid which contains sugar in some of its cells, hence the name Sugarscape. Agents&#39; role in this first model consists in wandering around the Sugarscape harvesting the greatest amount of sugar they can find.</p><h3 id="Environment"><a class="docs-heading-anchor" href="#Environment">Environment</a><a id="Environment-1"></a><a class="docs-heading-anchor-permalink" href="#Environment" title="Permalink"></a></h3><p>The environment is a 50×50 grid that wraps around forming a torus. Grid cells have both a sugar level and a sugar capacity c. A cell&#39;s sugar level is the number of units of sugar in the cell (potentially none), and its sugar capacity c is the maximum value the sugar level can take on that cell. Sugar capacity is fixed for each individual cell and may be different for different cells. The spatial distribution of sugar capacities depicts a sugar topography consisting of two peaks (with sugar capacity c = 4) separated by a valley, and surrounded by a desert region of sugarless cells (see Figure 1) - note, however, that the grid wraps around in both directions–.</p><p><img src="capacities.jpg" alt="Fig. 1: Spatial distribution of sugar capacities in the Sugarscape. Cells are coloured according to their sugar capacity."/></p><p>The Sugarscape obbeys the following rule:</p><p>Sugarscape growback rule G<span>$\alpha$</span>:     At each cell, sugar grows back at a rate of <span>$\alpha$</span> units per time-step up to the cell&#39;s capacity c.</p><h3 id="Agents"><a class="docs-heading-anchor" href="#Agents">Agents</a><a id="Agents-1"></a><a class="docs-heading-anchor-permalink" href="#Agents" title="Permalink"></a></h3><p>Every agent is endowed with individual (life-long) characteristics that condition her skills and capacities to survive in the Sugarscape. These individual attributes are:</p><ul><li>A vision <em>v</em>, which is the maximum number of cells the agent can see in each of the four principal lattice directions: north, south, east and west.</li><li>A metabolic rate <em>m</em>, which represents the units of sugar the agent burns per time-step.</li><li>A maximum age <em>max-age</em>, which is the maximum number of time-steps the agent can live.</li></ul><p>Agents also have the capacity to accumulate sugar wealth <em>w</em>. An agent&#39;s sugar wealth is incremented at the end of each time-step by the sugar collected and decremented by the agent&#39;s metabolic rate. <strong>Two agents are not allowed to occupy the same cell in the grid.</strong></p><p>The agents&#39; behaviour is determined by the following two rules:</p><h4 id="Agent-movement-rule-*M*:"><a class="docs-heading-anchor" href="#Agent-movement-rule-*M*:">Agent movement rule <em>M</em>:</a><a id="Agent-movement-rule-*M*:-1"></a><a class="docs-heading-anchor-permalink" href="#Agent-movement-rule-*M*:" title="Permalink"></a></h4><p>Consider the set of unoccupied cells within your vision (including the one you are standing on), identify the one(s) with the greatest amount of sugar, select the nearest one (randomly if there is more than one), move there and collect all the sugar in it. At this point, the agent&#39;s accumulated sugar wealth is incremented by the sugar collected and decremented by the agent&#39;s metabolic rate <em>m</em>. If at this moment the agent&#39;s sugar wealth is not greater than zero, then the agent dies.</p><h4 id="Agent-replacement-rule-*R*:"><a class="docs-heading-anchor" href="#Agent-replacement-rule-*R*:">Agent replacement rule <em>R</em>:</a><a id="Agent-replacement-rule-*R*:-1"></a><a class="docs-heading-anchor-permalink" href="#Agent-replacement-rule-*R*:" title="Permalink"></a></h4><p>Whenever an agent dies it is replaced by a new agent of age 0 placed on a randomly chosen unoccupied cell, having random attributes <em>v</em>, <em>m</em> and <em>max-age</em>, and random initial wealth w0. All random numbers are drawn from uniform distributions with ranges specified in Table 1 below.</p><h3 id="Scheduling-of-events"><a class="docs-heading-anchor" href="#Scheduling-of-events">Scheduling of events</a><a id="Scheduling-of-events-1"></a><a class="docs-heading-anchor-permalink" href="#Scheduling-of-events" title="Permalink"></a></h3><p>Scheduling is determined by the order in which the different rules <em>G</em>, <em>M</em> and <em>R</em> are fired in the model. Environmental rule <em>G</em> comes first, followed by agent rule <em>M</em> (which is executed by all agents in random order) and finally agent rule <em>R</em> is executed (again, by all agents in random order).</p><h3 id="Parameterisation"><a class="docs-heading-anchor" href="#Parameterisation">Parameterisation</a><a id="Parameterisation-1"></a><a class="docs-heading-anchor-permalink" href="#Parameterisation" title="Permalink"></a></h3><p>Our analysis corresponds to a model used by Epstein &amp; Axtell (1996, pg. 33) to study the emergent wealth distribution in the agent population. This model is parameterised as indicated in Table 1 below (where U[a,b] denotes a uniform distribution with range [a,b]).</p><p>Initially, each cell of the Sugarscape contains a sugar level equal to its sugar capacity c, and the 250 agents are created at a random unoccupied initial location and with random attributes (using the uniform distributions indicated in Table 1).</p><p><strong>Table 1</strong></p><table><tr><th style="text-align: right">Parameter</th><th style="text-align: right">Value</th></tr><tr><td style="text-align: right">Lattice length L</td><td style="text-align: right">50</td></tr><tr><td style="text-align: right">Number of sugar peaks</td><td style="text-align: right">2</td></tr><tr><td style="text-align: right">Growth rate <span>$\alpha$</span></td><td style="text-align: right">1</td></tr><tr><td style="text-align: right">Number of agents N</td><td style="text-align: right">250</td></tr><tr><td style="text-align: right">Agents&#39; initial wealth w0 distribution</td><td style="text-align: right">U[5,25]</td></tr><tr><td style="text-align: right">Agents&#39; metabolic rate m distribution</td><td style="text-align: right">U[1,4]</td></tr><tr><td style="text-align: right">Agents&#39; vision v distribution</td><td style="text-align: right">U[1,6]</td></tr><tr><td style="text-align: right">Agents&#39; maximum age max-age distribution</td><td style="text-align: right">U[60,100]</td></tr></table><pre><code class="language-julia">using Agents
using AgentsPlots
using Random

mutable struct SugarSeeker &lt;: AbstractAgent
    id::Int
    pos::Tuple{Int,Int}
    vision::Int
    metabolic_rate::Int
    age::Int
    max_age::Int
    wealth::Int
end</code></pre><p>Functions <code>distances</code> and <code>sugar_caps</code> produce a matrix for the distribution of sugar capacities.&quot;</p><pre><code class="language-">function distances(pos, sugar_peaks, max_sugar)
    all_dists = Array{Int,1}(undef, length(sugar_peaks))
    for (ind, peak) in enumerate(sugar_peaks)
        d = round(Int, sqrt(sum((pos .- peak) .^ 2)))
        all_dists[ind] = d
    end
    return minimum(all_dists)
end

function sugar_caps(dims, sugar_peaks, max_sugar, dia = 4)
    sugar_capacities = zeros(Int, dims)
    for i in 1:dims[1], j in 1:dims[2]
        sugar_capacities[i, j] = distances((i, j), sugar_peaks, max_sugar)
    end
    for i in 1:dims[1]
        for j in 1:dims[2]
            sugar_capacities[i, j] = max(0, max_sugar - (sugar_capacities[i, j] ÷ dia))
        end
    end
    return sugar_capacities
end

&quot;Start a sugarscape simulation&quot;
function sugarscape(;
    dims = (50, 50),
    sugar_peaks = ((10, 40), (40, 10)),
    growth_rate = 1,
    N = 250,
    w0_dist = (5, 25),
    metabolic_rate_dist = (1, 4),
    vision_dist = (1, 6),
    max_age_dist = (60, 100),
    max_sugar = 4,
)
    sugar_capacities = sugar_caps(dims, sugar_peaks, max_sugar, 6)
    sugar_values = deepcopy(sugar_capacities)
    space = GridSpace(dims, periodic = true, moore = true)
    properties = Dict(
        :growth_rate =&gt; growth_rate,
        :N =&gt; N,
        :w0_dist =&gt; w0_dist,
        :metabolic_rate_dist =&gt; metabolic_rate_dist,
        :vision_dist =&gt; vision_dist,
        :max_age_dist =&gt; max_age_dist,
        :sugar_values =&gt; sugar_values,
        :sugar_capacities =&gt; sugar_capacities,
    )
    model = AgentBasedModel(
        SugarSeeker,
        space,
        scheduler = random_activation,
        properties = properties,
    )
    for ag in 1:N
        add_agent_single!(
            model,
            rand(vision_dist[1]:vision_dist[2]),
            rand(metabolic_rate_dist[1]:metabolic_rate_dist[2]),
            0,
            rand(max_age_dist[1]:max_age_dist[2]),
            rand(w0_dist[1]:w0_dist[2]),
        )
    end
    return model
end

model = sugarscape()</code></pre><p>Fig. 1: Spatial distribution of sugar capacities in the Sugarscape. Cells are coloured according to their sugar capacity.</p><pre><code class="language-">heatmap(model.sugar_capacities)
savefig(&quot;capacities.jpg&quot;)</code></pre><pre><code class="language-julia">function env!(model)
    # At each cell, sugar grows back at a rate of $\alpha$ units per time-step up to the cell&#39;s capacity c.
    togrow = findall(
        x -&gt; model.sugar_values[x] &lt; model.sugar_capacities[x],
        1:prod(model.space.dimensions),
    )
    model.sugar_values[togrow] .+= model.growth_rate
end

function movement!(agent, model)
    posvertex = coord2vertex(agent.pos, model)
    newsite = posvertex
    # find all unoccupied cells within vision
    neighbors = node_neighbors(coord2vertex(agent.pos, model), model, agent.vision)
    empty_nodes = [i for i in neighbors if isempty(i, model)]
    if length(empty_nodes) &gt; 0
        # identify the one(s) with greatest amount of sugar
        maxsugar = maximum(model.sugar_values[empty_nodes])
        if maxsugar &gt; 0
            sugary_sites_inds = findall(x -&gt; x == maxsugar, model.sugar_values[empty_nodes])
            sugary_sites = empty_nodes[sugary_sites_inds]
            # select the nearest one (randomly if more than one)
            for dia in 1:(agent.vision)
                nn = node_neighbors(posvertex, model, dia)
                suitable = intersect(nn, sugary_sites)
                if length(suitable) &gt; 0
                    newsite = rand(suitable)
                    break
                end
            end
            # move there and collect all the sugar in it
            newsite != posvertex &amp;&amp; move_agent!(agent, newsite, model)
        end
    end
    # update wealth (collected - consumed)
    agent.wealth += (model.sugar_values[newsite] - agent.metabolic_rate)
    model.sugar_values[newsite] = 0
    # age
    agent.age += 1
end

function replacement!(agent, model)
    # If the agent&#39;s sugar wealth become zero or less, it dies
    if agent.wealth &lt;= 0 || agent.age &gt;= agent.max_age
        kill_agent!(agent, model)
        # Whenever an agent dies, a young one is added to a random pos.
        # New agent has random attributes
        add_agent_single!(
            model,
            rand(model.vision_dist[1]:model.vision_dist[2]),
            rand(model.metabolic_rate_dist[1]:model.metabolic_rate_dist[2]),
            0,
            rand(model.max_age_dist[1]:model.max_age_dist[2]),
            rand(model.w0_dist[1]:model.w0_dist[2]),
        )
    end
end

function agent_step!(agent, model)
    movement!(agent, model)
    replacement!(agent, model)
end</code></pre><pre class="documenter-example-output">agent_step! (generic function with 1 method)</pre><p>The following animation shows the emergent unequal distribution of agents on resourceful areas.</p><pre><code class="language-">anim = @animate for i in 1:50
    step!(model, agent_step!, env!, 1)
    p1 = heatmap(model.sugar_values)
    p2 = plotabm(model, as = 3, am = :square, ac = :blue)
    title!(p1, &quot;Sugar levels&quot;)
    title!(p2, &quot;Agents\n Step $i&quot;)
    p = plot(p1, p2)
end
gif(anim, &quot;sugar.gif&quot;, fps = 8)</code></pre><h3 id="Distribution-of-wealth-across-individuals"><a class="docs-heading-anchor" href="#Distribution-of-wealth-across-individuals">Distribution of wealth across individuals</a><a id="Distribution-of-wealth-across-individuals-1"></a><a class="docs-heading-anchor-permalink" href="#Distribution-of-wealth-across-individuals" title="Permalink"></a></h3><pre><code class="language-">model2 = sugarscape()
adata, _ = run!(model2, agent_step!, env!, 20, adata = [:wealth])

anim2 = @animate for i in 0:20
    histogram(
        adata[adata.step .== i, :wealth],
        legend = false,
        color = :black,
        nbins = 15,
        title = &quot;step $i&quot;,
    )
end</code></pre><p>We see that the distribution of wealth shifts from a more or less uniform distribution to a skewed distribution.</p><pre><code class="language-">gif(anim2, fps = 3)</code></pre><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><p>BUZING P, Eiben A &amp; Schut M (2005) Emerging communication and cooperation in evolving agent societies. Journal of Artificial Societies and Social Simulation 8(1)2. http://jasss.soc.surrey.ac.uk/8/1/2.html.</p><p>EPSTEIN J M (1999) Agent-Based Computational Models And Generative Social Science. Complexity 4(5), pp. 41-60.</p><p>EPSTEIN J M &amp; Axtell R L (1996) Growing Artificial Societies: Social Science from the Bottom Up. The MIT Press.</p><p>FLENTGE F, Polani D &amp; Uthmann T (2001) Modelling the emergence of possession norms using memes. Journal of Artificial Societies and Social Simulation 4(4)3. http://jasss.soc.surrey.ac.uk/4/4/3.html.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../schelling/">« Schelling&#39;s segregation model</a><a class="docs-footer-nextpage" href="../sir/">SIR model for the spread of COVID-19 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 16 September 2020 23:13">Wednesday 16 September 2020</span>. Using Julia version 1.5.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
